name: Process Department Content
on:
  issues:
    types: [labeled, edited]

# æ·»åŠ å¹¶å‘æ§åˆ¶ï¼Œé˜²æ­¢åŒä¸€Issueè¢«å¤šæ¬¡å¤„ç†
concurrency:
  group: issue-${{ github.event.issue.number }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  generate-content:
    runs-on: ubuntu-latest
    # ç¡®ä¿åªæœ‰å¸¦æœ‰new-contentæ ‡ç­¾çš„Issueæ‰ä¼šè§¦å‘
    if: |
      contains(github.event.issue.labels.*.name, 'new-content') && 
      (github.event.action == 'labeled' && !contains(github.event.issue.labels.*.name, 'å¤„ç†ä¸­')) || 
      (github.event.action == 'edited' && contains(github.event.issue.labels.*.name, 'new-content'))

    steps:
      # æ·»åŠ æ–°æ­¥éª¤ï¼šè®°å½•è§¦å‘ç±»å‹
      - name: è®°å½•è§¦å‘ç±»å‹
        id: trigger-type
        run: |
          if [ "${{ github.event.action }}" = "edited" ]; then
            echo "is_edit=true" >> $GITHUB_OUTPUT
          else
            echo "is_edit=false" >> $GITHUB_OUTPUT
          fi

      # 1. æ·»åŠ å¤„ç†ä¸­æ ‡ç­¾å¹¶æ·»åŠ çŸ­æš‚å»¶è¿Ÿç¡®ä¿æ ‡ç­¾ç”Ÿæ•ˆ
      - name: æ·»åŠ å¤„ç†ä¸­æ ‡ç­¾
        uses: actions/github-script@v6
        with:
          script: |
            // å¦‚æœæ˜¯ç¼–è¾‘è§¦å‘ï¼Œå…ˆç§»é™¤å¤„ç†å®Œæˆæ ‡ç­¾
            if ('${{ steps.trigger-type.outputs.is_edit }}' === 'true') {
              try {
                await github.rest.issues.removeLabel({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: 'å¤„ç†å®Œæˆ'
                });
              } catch (error) {
                console.log('ç§»é™¤å¤„ç†å®Œæˆæ ‡ç­¾å¤±è´¥:', error.message);
              }
            }

            await github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['å¤„ç†ä¸­']
            });
            // æ·»åŠ çŸ­æš‚å»¶è¿Ÿç¡®ä¿æ ‡ç­¾ç”Ÿæ•ˆ
            await new Promise(resolve => setTimeout(resolve, 2000));

      # 2. åˆ›å»ºæˆ–æ›´æ–°å¤„ç†è¯„è®º
      - name: åˆ›å»ºæˆ–æ›´æ–°å¤„ç†è¯„è®º
        id: initial-comment
        uses: actions/github-script@v6
        with:
          script: |
            let commentBody = 'â³ æ­£åœ¨å¤„ç†æ‚¨çš„è¯·æ±‚ï¼Œè¯·ç¨å€™...';
            if ('${{ steps.trigger-type.outputs.is_edit }}' === 'true') {
              commentBody = 'â³ Issueå·²ç¼–è¾‘ï¼Œæ­£åœ¨æ›´æ–°ç›¸å…³PRå†…å®¹...';
            }

            // æŸ¥æ‰¾æ˜¯å¦å·²å­˜åœ¨å¤„ç†è¯„è®º
            const comments = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            const processingComment = comments.data.find(comment => 
              comment.body.includes('æ­£åœ¨å¤„ç†æ‚¨çš„è¯·æ±‚') || 
              comment.body.includes('Issueå·²ç¼–è¾‘') || 
              comment.body.includes('æ–‡ä»¶å·²æˆåŠŸç”Ÿæˆ') ||
              comment.body.includes('å·²æ›´æ–°ç°æœ‰PR')
            );

            let commentId;
            if (processingComment) {
              // æ›´æ–°ç°æœ‰è¯„è®º
              await github.rest.issues.updateComment({
                comment_id: processingComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody
              });
              commentId = processingComment.id;
            } else {
              // åˆ›å»ºæ–°è¯„è®º
              const result = await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody
              });
              commentId = result.data.id;
            }

            return commentId;

      # 3. æ£€å‡ºä»£ç åº“
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 4. å®‰è£…å¿…è¦å·¥å…·
      - name: å®‰è£…ä¾èµ–
        run: |
          sudo wget -O /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.35.1/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          pip install pyyaml

      # 5. ä»Issueå†…å®¹æå–å­—æ®µ
      - name: æå–æ¨¡æ¿å­—æ®µ
        id: extract-fields
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          cat > extract.py << 'EOF'
          import os, sys, re, html

          def unescape_markdown(text):
              """è§£é™¤Markdownè½¬ä¹‰"""
              if not text:
                  return text
              # è§£é™¤å¸¸è§çš„Markdownè½¬ä¹‰å­—ç¬¦
              text = text.replace('\\*', '*')
              text = text.replace('\\#', '#')
              text = text.replace('\\`', '`')
              text = text.replace('\\\\', '\\')
              return text

          def extract_section(body, section_name):
              """æå–æŒ‡å®šéƒ¨åˆ†çš„å†…å®¹"""
              if not body:
                  return None
                  
              marker = "### " + section_name
              alt_marker = "**" + section_name + "**"
              
              # å°è¯•æ‰¾æ ‡å‡†æ ¼å¼
              if marker in body:
                  start = body.find(marker) + len(marker)
                  next_section = body.find("###", start)
                  section_content = body[start:next_section].strip() if next_section != -1 else body[start:].strip()
                  return section_content
              
              # å°è¯•ä»è¡¨æ ¼æå–
              elif section_name + " " in body:
                  pattern = r'(?:' + re.escape(section_name) + r'|' + re.escape(alt_marker) + r')\s+([^\n|]+)'
                  match = re.search(pattern, body)
                  if match:
                      return match.group(1).strip()
              
              return None
              
          def extract_content(body):
              """æå–å†…å®¹ - ä»ç¬¬ä¸€ä¸ª```markdownå¼€å§‹ï¼Œåˆ°æœ€åä¸€ä¸ª```ç»“æŸ"""
              markdown_start = body.find("```markdown")
              if markdown_start == -1:
                  return None
              
              content_start = body.find("\n", markdown_start)
              if content_start == -1:
                  return None
              content_start += 1
              
              markdown_end = body.rfind("```")
              if markdown_end == -1 or markdown_end <= content_start:
                  return None
              
              content = body[content_start:markdown_end].strip()
              content = unescape_markdown(content)
              content = content.replace('\\n', '\n')
              return content

          # ä¸»ç¨‹åº
          body = os.environ.get("ISSUE_BODY", "")

          try:
              department = extract_section(body, "éƒ¨é—¨åç§°")
              title = extract_section(body, "æ ‡é¢˜")
              filename = extract_section(body, "æ–‡ä»¶å")
              content = extract_content(body)

              # å»æ‰æ–‡ä»¶ååç¼€ï¼Œè‡ªåŠ¨æ›¿æ¢æ–‡ä»¶åé‡Œçš„_ä¸º-ï¼Œè‡ªåŠ¨å»æ‰ç©ºæ ¼
              if filename and filename.endswith('.md'):
                  filename = filename.replace('.md', '')
                  filename = filename.replace('_', '-').replace(' ', '')
              
              # éªŒè¯å¿…è¦å­—æ®µ
              missing = []
              if not department:
                  missing.append("éƒ¨é—¨åç§°")
              if not filename:
                  missing.append("æ–‡ä»¶å")
              if not content:
                  missing.append("ä¸»è¦å†…å®¹")
                  
              if missing:
                  print(f"é”™è¯¯: ç¼ºå°‘å¿…è¦å­—æ®µ: {', '.join(missing)}")
                  sys.exit(1)
              
              # è¾“å‡ºåˆ°ç¯å¢ƒå˜é‡
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write(f"DEPARTMENT={department}\n")
                  f.write(f"FILENAME={filename}\n")
                  if title:
                      f.write(f"TITLE={title}\n")
                  f.write(f"CONTENT<<EOF_CONTENT\n{content}\nEOF_CONTENT\n")
          except Exception as e:
              print(f"æå–è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {str(e)}")
              sys.exit(1)
          EOF

          python extract.py

      # 6. å¤„ç†æå–å¤±è´¥çš„æƒ…å†µ
      - name: å¤„ç†æå–å¤±è´¥
        if: ${{ failure() && steps.extract-fields.outcome == 'failure' }}
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.issues.updateComment({
              comment_id: ${{ steps.initial-comment.outputs.script-result }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: 'âŒ é”™è¯¯ï¼šæ— æ³•ä»Issueå†…å®¹ä¸­æå–å¿…è¦ä¿¡æ¯ã€‚è¯·ç¡®ä¿åŒ…å«ä»¥ä¸‹å¿…è¦å­—æ®µï¼š\n\n```\n### éƒ¨é—¨åç§°\n<éƒ¨é—¨åç§°>\n\n### æ–‡ä»¶å\n<æ–‡ä»¶å>\n\n### ä¸»è¦å†…å®¹\n```markdown\n<å†…å®¹>\n```\n```'
            });
            await github.rest.issues.removeLabel({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'å¤„ç†ä¸­'
            });

      # 7. åŒ¹é…éƒ¨é—¨ç›®å½•
      - name: åŒ¹é…éƒ¨é—¨ç›®å½•
        id: find-department
        env:
          DEPARTMENT: ${{ steps.extract-fields.outputs.DEPARTMENT }}
        run: |
          BASE_DIR="src"
          TARGET_DIR=""

          for dir in $(find $BASE_DIR -maxdepth 1 -type d); do
            readme="$dir/README.md"
            if [ -f "$readme" ]; then
              frontmatter=$(sed -n '/^---$/,/^---$/p' $readme | head -n -1 | tail -n +2)
              title=$(python -c "import yaml; print(yaml.safe_load('''$frontmatter''').get('title', ''))")
              
              if [ "$title" = "$DEPARTMENT" ]; then
                TARGET_DIR="${dir#*/}"
                break
              fi
            fi
          done

          if [ -z "$TARGET_DIR" ]; then
            echo "æœªæ‰¾åˆ°åŒ¹é…éƒ¨é—¨ç›®å½•ï¼"
            exit 1
          fi

          echo "target_dir=$TARGET_DIR" >> $GITHUB_OUTPUT

      # 8. å¤„ç†éƒ¨é—¨åŒ¹é…å¤±è´¥
      - name: å¤„ç†éƒ¨é—¨åŒ¹é…å¤±è´¥
        if: ${{ failure() && steps.find-department.outcome == 'failure' }}
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.issues.updateComment({
              comment_id: ${{ steps.initial-comment.outputs.script-result }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: 'âŒ é”™è¯¯ï¼šæœªæ‰¾åˆ°ä¸éƒ¨é—¨åç§°"${{ steps.extract-fields.outputs.DEPARTMENT }}"åŒ¹é…çš„ç›®å½•ï¼Œè¯·æ£€æŸ¥éƒ¨é—¨åç§°æ˜¯å¦æ­£ç¡®'
            });
            await github.rest.issues.removeLabel({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'å¤„ç†ä¸­'
            });

      # 9. ç”Ÿæˆæ–‡ä»¶
      - name: ç”Ÿæˆæ–‡ä»¶
        id: generate-file
        env:
          DEPARTMENT: ${{ steps.extract-fields.outputs.DEPARTMENT }}
          FILENAME: ${{ steps.extract-fields.outputs.FILENAME }}
          TITLE: ${{ steps.extract-fields.outputs.TITLE }}
          CONTENT: ${{ steps.extract-fields.outputs.CONTENT }}
          TARGET_DIR: ${{ steps.find-department.outputs.target_dir }}
          ISSUE_AUTHOR: ${{ github.event.issue.user.login }}
        run: |
          CLEAN_FILENAME=$(echo "$FILENAME" | tr ' ' '-' | tr -cd '[:alnum:]-_')
          FILE_PATH="src/$TARGET_DIR/${CLEAN_FILENAME}.md"
          echo "file_path=$FILE_PATH" >> $GITHUB_OUTPUT
          echo "clean_filename=$CLEAN_FILENAME" >> $GITHUB_OUTPUT

          # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
          if [ -f "$FILE_PATH" ]; then
            echo "æ–‡ä»¶å·²å­˜åœ¨ï¼Œå°†æ›´æ–°å†…å®¹"
            echo "is_update=true" >> $GITHUB_OUTPUT
          else
            echo "is_update=false" >> $GITHUB_OUTPUT
          fi

          ARTICLE_TITLE="${TITLE:-æ¥è‡ª $DEPARTMENT çš„æŠ•ç¨¿}"
          echo "---" > $FILE_PATH
          echo "title: $ARTICLE_TITLE" >> $FILE_PATH
          echo "---" >> $FILE_PATH
          echo "" >> $FILE_PATH
          echo "$CONTENT" >> $FILE_PATH
          echo "" >> $FILE_PATH
          echo "---" >> $FILE_PATH
          echo "" >> $FILE_PATH
          echo "> æŠ•ç¨¿äºº: [@$ISSUE_AUTHOR](https://github.com/$ISSUE_AUTHOR)" >> $FILE_PATH

      # 10. æ£€æŸ¥æ˜¯å¦å·²æœ‰å¯¹åº”PR
      - name: æ£€æŸ¥ç°æœ‰PR
        id: check-existing-pr
        uses: actions/github-script@v6
        with:
          script: |
            // æŸ¥æ‰¾ä¸å½“å‰Issueç›¸å…³çš„PR
            const pulls = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:content-update/issue-${context.issue.number}`
            });

            if (pulls.data.length > 0) {
              return pulls.data[0].number;
            }

            // æ£€æŸ¥PRæ­£æ–‡ä¸­æ˜¯å¦åŒ…å«å½“å‰Issueç¼–å·
            const allPulls = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });

            for (const pr of allPulls.data) {
              if (pr.body && pr.body.includes(`closes #${context.issue.number}`)) {
                return pr.number;
              }
            }

            return null;

      # 11. åˆ›å»ºåˆ†æ”¯å¹¶æäº¤æ›´æ”¹
      - name: åˆ›å»ºåˆ†æ”¯å¹¶æäº¤æ›´æ”¹
        id: create-branch
        # ä¿®æ”¹æ¡ä»¶ï¼šå½“æ˜¯ç¼–è¾‘è§¦å‘æ—¶ï¼Œå§‹ç»ˆæ‰§è¡Œæ­¤æ­¥éª¤
        if: ${{ !steps.check-existing-pr.outputs.script-result || steps.trigger-type.outputs.is_edit == 'true' }}
        env:
          FILENAME: ${{ steps.generate-file.outputs.clean_filename }}
          FILE_PATH: ${{ steps.generate-file.outputs.file_path }}
          IS_UPDATE: ${{ steps.generate-file.outputs.is_update }}
          IS_EDIT: ${{ steps.trigger-type.outputs.is_edit }}
        run: |
          # ä½¿ç”¨å›ºå®šæ ¼å¼çš„åˆ†æ”¯å
          BRANCH_NAME="content-update/issue-${{ github.event.issue.number }}"

          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # æ£€æŸ¥åˆ†æ”¯æ˜¯å¦å·²å­˜åœ¨
          if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
            echo "åˆ†æ”¯å·²å­˜åœ¨ï¼Œå°†ç›´æ¥ä½¿ç”¨"
            git checkout $BRANCH_NAME
          else
            echo "åˆ›å»ºæ–°åˆ†æ”¯"
            git checkout -b $BRANCH_NAME
          fi

          git add "$FILE_PATH"

          if [ "$IS_EDIT" = "true" ]; then
            git commit -m "æ›´æ–°å†…å®¹(ç”±Issueç¼–è¾‘è§¦å‘): $FILENAME (éƒ¨é—¨: ${{ steps.extract-fields.outputs.DEPARTMENT }}) [Issue #${{ github.event.issue.number }}]"
          elif [ "$IS_UPDATE" = "true" ]; then
            git commit -m "æ›´æ–°å†…å®¹: $FILENAME (éƒ¨é—¨: ${{ steps.extract-fields.outputs.DEPARTMENT }}) [Issue #${{ github.event.issue.number }}]"
          else
            git commit -m "æ·»åŠ å†…å®¹: $FILENAME (éƒ¨é—¨: ${{ steps.extract-fields.outputs.DEPARTMENT }}) [Issue #${{ github.event.issue.number }}]"
          fi

          git push origin $BRANCH_NAME --force

          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "repo_url=https://github.com/${{ github.repository }}" >> $GITHUB_OUTPUT

      # 12. åˆ›å»ºæˆ–æ›´æ–°Pull Request
      - name: åˆ›å»ºæˆ–æ›´æ–°Pull Request
        id: create-pr
        uses: actions/github-script@v6
        env:
          BRANCH_NAME: ${{ steps.create-branch.outputs.branch_name || format('content-update/issue-{0}', github.event.issue.number) }}
          DEPARTMENT: ${{ steps.extract-fields.outputs.DEPARTMENT }}
          FILENAME: ${{ steps.generate-file.outputs.clean_filename }}
          TITLE: ${{ steps.extract-fields.outputs.TITLE }}
          TARGET_DIR: ${{ steps.find-department.outputs.target_dir }}
          EXISTING_PR: ${{ steps.check-existing-pr.outputs.script-result }}
          IS_EDIT: ${{ steps.trigger-type.outputs.is_edit }}
          REPO_URL: ${{ format('https://github.com/{0}', github.repository) }}
        with:
          script: |
            const title = `å†…å®¹æŠ•ç¨¿: ${process.env.DEPARTMENT} - ${process.env.TITLE || process.env.FILENAME}`;
            const body = `ç”± Issue #${context.issue.number} è‡ªåŠ¨ç”Ÿæˆ
            éƒ¨é—¨ç›®å½•: \`src/${process.env.TARGET_DIR}\`
            ${process.env.IS_EDIT === 'true' ? '> ğŸ“ æ­¤PRå·²æ ¹æ®Issueç¼–è¾‘å†…å®¹æ›´æ–°\n' : ''}
            ---

            closes #${context.issue.number}`;

            let prNumber;

            try {
              if (process.env.EXISTING_PR) {
                console.log(`æ›´æ–°ç°æœ‰PR #${process.env.EXISTING_PR}`);
                await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: process.env.EXISTING_PR,
                  title: title,
                  body: body
                });
                prNumber = process.env.EXISTING_PR;
              } else {
                // å†æ¬¡æ£€æŸ¥æ˜¯å¦æœ‰ç°æœ‰PRï¼ˆé€šè¿‡åˆ†æ”¯åç§°ï¼‰
                const branchName = process.env.BRANCH_NAME;
                const pulls = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open',
                  head: `${context.repo.owner}:${branchName}`
                });
                
                if (pulls.data.length > 0) {
                  // å¦‚æœæ‰¾åˆ°ç°æœ‰PRï¼Œåˆ™æ›´æ–°å®ƒ
                  console.log(`æ‰¾åˆ°ç°æœ‰PR #${pulls.data[0].number}ï¼Œæ­£åœ¨æ›´æ–°...`);
                  await github.rest.pulls.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pulls.data[0].number,
                    title: title,
                    body: body
                  });
                  prNumber = pulls.data[0].number;
                } else {
                  // å¦‚æœç¡®å®æ²¡æœ‰ç°æœ‰PRï¼Œåˆ™åˆ›å»ºæ–°PR
                  console.log('åˆ›å»ºæ–°PR');
                  try {
                    const result = await github.rest.pulls.create({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      title: title,
                      body: body,
                      head: branchName,
                      base: 'main'
                    });
                    prNumber = result.data.number;
                  } catch (error) {
                    // å¦‚æœåˆ›å»ºå¤±è´¥ï¼Œå°è¯•å†æ¬¡æŸ¥æ‰¾å¯èƒ½å­˜åœ¨çš„PR
                    if (error.status === 422) {
                      console.log('åˆ›å»ºPRå¤±è´¥ï¼Œå°è¯•æŸ¥æ‰¾å·²å­˜åœ¨çš„PR...');
                      const allPulls = await github.rest.pulls.list({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        state: 'open'
                      });
                      
                      // æŸ¥æ‰¾ä»»ä½•å¯èƒ½å…³è”çš„PR
                      for (const pr of allPulls.data) {
                        if (pr.head.ref === branchName || (pr.body && pr.body.includes(`closes #${context.issue.number}`))) {
                          console.log(`æ‰¾åˆ°å…³è”PR #${pr.number}ï¼Œå°†ä½¿ç”¨è¯¥PR`);
                          await github.rest.pulls.update({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            pull_number: pr.number,
                            title: title,
                            body: body
                          });
                          prNumber = pr.number;
                          break;
                        }
                      }
                      
                      if (!prNumber) {
                        throw new Error(`æ— æ³•åˆ›å»ºæˆ–æ‰¾åˆ°å…³è”çš„PR: ${error.message}`);
                      }
                    } else {
                      throw error;
                    }
                  }
                }
              }
              
              return prNumber.toString();
            } catch (error) {
              console.log(`å¤„ç†PRæ—¶å‡ºé”™: ${error.message}`);
              throw error;
            }

      # 13. æ›´æ–°è¯„è®ºé€šçŸ¥ç»“æœ
      - name: æ›´æ–°å¤„ç†ç»“æœè¯„è®º
        if: always()
        uses: actions/github-script@v6
        env:
          REPO_URL: ${{ format('https://github.com/{0}', github.repository) }}
          BRANCH_NAME: ${{ steps.create-branch.outputs.branch_name || format('content-update/issue-{0}', github.event.issue.number) }}
          DEPARTMENT_DIR: ${{ steps.find-department.outputs.target_dir }}
          FILENAME: ${{ steps.generate-file.outputs.clean_filename }}
          COMMENT_ID: ${{ steps.initial-comment.outputs.result }}
        with:
          script: |
            // å»é™¤å¼•å·ï¼Œç¡®ä¿PRå·æ˜¯çº¯æ•°å­—
            const prNumber = ${{ steps.create-pr.outputs.result || 'null' }};
            const existingPr = ${{ steps.check-existing-pr.outputs.script-result || 'null' }};
            const success = prNumber && prNumber !== null;
            const isEdit = '${{ steps.trigger-type.outputs.is_edit }}' === 'true';

            // è·å–è¯„è®ºID
            const commentId = process.env.COMMENT_ID;

            if (success) {
              let message;
              if (isEdit) {
                message = `âœ… Issueç¼–è¾‘å†…å®¹å·²æ›´æ–°åˆ°PR #${prNumber}\n\nä½ å¯ä»¥åœ¨ä¸‹é¢é“¾æ¥ä¸­æŸ¥çœ‹Pull Requestçš„è¯¦ç»†å†…å®¹å’Œä¿®æ”¹æƒ…å†µ\n${process.env.REPO_URL}/pull/${prNumber}\n\nç›´æ¥ç¼–è¾‘æ–‡ä»¶: ${process.env.REPO_URL}/edit/${process.env.BRANCH_NAME}/src/${process.env.DEPARTMENT_DIR}/${process.env.FILENAME}.md\n\næŸ¥çœ‹æ–‡ä»¶: ${process.env.REPO_URL}/blob/${process.env.BRANCH_NAME}/src/${process.env.DEPARTMENT_DIR}/${process.env.FILENAME}.md\n\nä½ å¯ä»¥åœ¨åˆå¹¶å3åˆ†é’Ÿå·¦å³è®¿é—®ç”Ÿæˆåçš„é¡µé¢URLï¼šhttps://w1ndys.github.io/QFNUCyberWiki/${process.env.DEPARTMENT_DIR}/${process.env.FILENAME}.html`;
              } else if (existingPr) {
                message = `â™»ï¸ å·²æ›´æ–°ç°æœ‰PR [#${prNumber}](${process.env.REPO_URL}/pull/${prNumber}) å†…å®¹\n\nç›´æ¥ç¼–è¾‘æ–‡ä»¶: ${process.env.REPO_URL}/edit/${process.env.BRANCH_NAME}/src/${process.env.DEPARTMENT_DIR}/${process.env.FILENAME}.md\n\næŸ¥çœ‹æ–‡ä»¶: ${process.env.REPO_URL}/blob/${process.env.BRANCH_NAME}/src/${process.env.DEPARTMENT_DIR}/${process.env.FILENAME}.md`;
              } else {
                message = `âœ… æ–‡ä»¶å·²æˆåŠŸç”Ÿæˆå¹¶æäº¤åˆ°åˆ†æ”¯ [\`${process.env.BRANCH_NAME}\`](${process.env.REPO_URL}/tree/${process.env.BRANCH_NAME})ï¼\n\nPR: [#${prNumber}](${process.env.REPO_URL}/pull/${prNumber})\n\nç›´æ¥ç¼–è¾‘æ–‡ä»¶: ${process.env.REPO_URL}/edit/${process.env.BRANCH_NAME}/src/${process.env.DEPARTMENT_DIR}/${process.env.FILENAME}.md\n\næŸ¥çœ‹æ–‡ä»¶: ${process.env.REPO_URL}/blob/${process.env.BRANCH_NAME}/src/${process.env.DEPARTMENT_DIR}/${process.env.FILENAME}.md\n\nä½ å¯ä»¥åœ¨åˆå¹¶å3åˆ†é’Ÿå·¦å³è®¿é—®ç”Ÿæˆåçš„é¡µé¢URLï¼šhttps://w1ndys.github.io/QFNUCyberWiki/${process.env.DEPARTMENT_DIR}/${process.env.FILENAME}.html\n\nå½“PRè¢«åˆå¹¶æ—¶ï¼Œæ­¤Issueå°†è‡ªåŠ¨å…³é—­ã€‚`;
              }

              try {
                if (commentId) {
                  await github.rest.issues.updateComment({
                    comment_id: commentId,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: message
                  });
                } else {
                  await github.rest.issues.createComment({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: message
                  });
                }
              } catch (error) {
                console.log('æ›´æ–°è¯„è®ºå¤±è´¥:', error.message);
                
                // å°è¯•åˆ›å»ºæ–°è¯„è®º
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: message
                });
              }
            } else {
              try {
                if (commentId) {
                  await github.rest.issues.updateComment({
                    comment_id: commentId,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: 'âŒ å¤„ç†è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼Œè¯·æ£€æŸ¥Issueæ ¼å¼æ˜¯å¦æ­£ç¡®æˆ–è”ç³»ç®¡ç†å‘˜'
                  });
                } else {
                  await github.rest.issues.createComment({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: 'âŒ å¤„ç†è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼Œè¯·æ£€æŸ¥Issueæ ¼å¼æ˜¯å¦æ­£ç¡®æˆ–è”ç³»ç®¡ç†å‘˜'
                  });
                }
              } catch (error) {
                console.log('æ›´æ–°é”™è¯¯è¯„è®ºå¤±è´¥:', error.message);
              }
            }

            // æ›´æ–°æ ‡ç­¾çŠ¶æ€
            try {
              await github.rest.issues.removeLabel({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: 'å¤„ç†ä¸­'
              });

              if (success) {
                await github.rest.issues.addLabels({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  labels: ['å¤„ç†å®Œæˆ']
                });
              }
            } catch (error) {
              console.log('æ›´æ–°æ ‡ç­¾å¤±è´¥:', error.message);
            }
